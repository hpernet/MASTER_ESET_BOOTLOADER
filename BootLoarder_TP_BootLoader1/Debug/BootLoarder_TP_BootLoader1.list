
BootLoarder_TP_BootLoader1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c4  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000960  080001c4  080001c4  000101c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  08000b24  08000b24  00020004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  08000b24  08000b24  00020004  2**0
                  CONTENTS
  4 .ARM          00000000  08000b24  08000b24  00020004  2**0
                  CONTENTS
  5 .preinit_array 00000000  08000b24  08000b24  00020004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08000b24  08000b24  00010b24  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08000b28  08000b28  00010b28  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000004  20000000  08000b2c  00020000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000040  20000004  08000b30  00020004  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  20000044  08000b30  00020044  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00020004  2**0
                  CONTENTS, READONLY
 12 .debug_info   00002b5b  00000000  00000000  00020034  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00000c4c  00000000  00000000  00022b8f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000380  00000000  00000000  000237e0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 000002f8  00000000  00000000  00023b60  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0002065a  00000000  00000000  00023e58  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0000399b  00000000  00000000  000444b2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    000c7037  00000000  00000000  00047e4d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000050  00000000  00000000  0010ee84  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00000ba8  00000000  00000000  0010eed4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001c4 <__do_global_dtors_aux>:
 80001c4:	b510      	push	{r4, lr}
 80001c6:	4c05      	ldr	r4, [pc, #20]	; (80001dc <__do_global_dtors_aux+0x18>)
 80001c8:	7823      	ldrb	r3, [r4, #0]
 80001ca:	b933      	cbnz	r3, 80001da <__do_global_dtors_aux+0x16>
 80001cc:	4b04      	ldr	r3, [pc, #16]	; (80001e0 <__do_global_dtors_aux+0x1c>)
 80001ce:	b113      	cbz	r3, 80001d6 <__do_global_dtors_aux+0x12>
 80001d0:	4804      	ldr	r0, [pc, #16]	; (80001e4 <__do_global_dtors_aux+0x20>)
 80001d2:	f3af 8000 	nop.w
 80001d6:	2301      	movs	r3, #1
 80001d8:	7023      	strb	r3, [r4, #0]
 80001da:	bd10      	pop	{r4, pc}
 80001dc:	20000004 	.word	0x20000004
 80001e0:	00000000 	.word	0x00000000
 80001e4:	08000b0c 	.word	0x08000b0c

080001e8 <frame_dummy>:
 80001e8:	b508      	push	{r3, lr}
 80001ea:	4b03      	ldr	r3, [pc, #12]	; (80001f8 <frame_dummy+0x10>)
 80001ec:	b11b      	cbz	r3, 80001f6 <frame_dummy+0xe>
 80001ee:	4903      	ldr	r1, [pc, #12]	; (80001fc <frame_dummy+0x14>)
 80001f0:	4803      	ldr	r0, [pc, #12]	; (8000200 <frame_dummy+0x18>)
 80001f2:	f3af 8000 	nop.w
 80001f6:	bd08      	pop	{r3, pc}
 80001f8:	00000000 	.word	0x00000000
 80001fc:	20000008 	.word	0x20000008
 8000200:	08000b0c 	.word	0x08000b0c

08000204 <GPIO_Init>:
#include <stdint.h>
#include <stm32f446xx.h>
#include "main.h"
#include "gpio.h"

void GPIO_Init(void){
 8000204:	b480      	push	{r7}
 8000206:	af00      	add	r7, sp, #0
	/* Clock Init */
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOCEN;
 8000208:	4b0a      	ldr	r3, [pc, #40]	; (8000234 <GPIO_Init+0x30>)
 800020a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800020c:	4a09      	ldr	r2, [pc, #36]	; (8000234 <GPIO_Init+0x30>)
 800020e:	f043 0305 	orr.w	r3, r3, #5
 8000212:	6313      	str	r3, [r2, #48]	; 0x30

	/* GPIO Init */
	GPIOA->MODER |= OUTPUT_MODE <<10;		// PA5 Output LED
 8000214:	4b08      	ldr	r3, [pc, #32]	; (8000238 <GPIO_Init+0x34>)
 8000216:	681b      	ldr	r3, [r3, #0]
 8000218:	4a07      	ldr	r2, [pc, #28]	; (8000238 <GPIO_Init+0x34>)
 800021a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800021e:	6013      	str	r3, [r2, #0]
	GPIOC->MODER |= INPUT_MODE	<< 26;		// PC13 Input Push-Button
 8000220:	4b06      	ldr	r3, [pc, #24]	; (800023c <GPIO_Init+0x38>)
 8000222:	4a06      	ldr	r2, [pc, #24]	; (800023c <GPIO_Init+0x38>)
 8000224:	681b      	ldr	r3, [r3, #0]
 8000226:	6013      	str	r3, [r2, #0]
}
 8000228:	bf00      	nop
 800022a:	46bd      	mov	sp, r7
 800022c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000230:	4770      	bx	lr
 8000232:	bf00      	nop
 8000234:	40023800 	.word	0x40023800
 8000238:	40020000 	.word	0x40020000
 800023c:	40020800 	.word	0x40020800

08000240 <main>:
	USART2->DR = ch;
}

// Main
int main(void)
{
 8000240:	b5b0      	push	{r4, r5, r7, lr}
 8000242:	b08c      	sub	sp, #48	; 0x30
 8000244:	af00      	add	r7, sp, #0
	// Variable declaration
	void (*p_application_function) (void);   // pointer function on user application
	uint32_t index    = 0U;
 8000246:	2300      	movs	r3, #0
 8000248:	62fb      	str	r3, [r7, #44]	; 0x2c
	uint8_t  rx_value = 0U;
 800024a:	2300      	movs	r3, #0
 800024c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	FLASH_EraseInitTypeDef flash_erase;
	uint32_t flash_sector_error;

	// Initialize Application function address
	p_application_function = *(ADDR_FLASH_SECTOR_2 + 1);
 8000250:	4b34      	ldr	r3, [pc, #208]	; (8000324 <main+0xe4>)
 8000252:	681b      	ldr	r3, [r3, #0]
 8000254:	623b      	str	r3, [r7, #32]

	// Initialize peripherals
	GPIO_Init();
 8000256:	f7ff ffd5 	bl	8000204 <GPIO_Init>
	USART2_Init();
 800025a:	f000 f8ab 	bl	80003b4 <USART2_Init>

	// Check pushbutton
	if((GPIOC->IDR & (1<<13)) == (1<<13))
 800025e:	4b32      	ldr	r3, [pc, #200]	; (8000328 <main+0xe8>)
 8000260:	691b      	ldr	r3, [r3, #16]
 8000262:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000266:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800026a:	d10c      	bne.n	8000286 <main+0x46>
	{
		// Set the Vector Table offset to the Application
		SCB->VTOR = ADDR_FLASH_SECTOR_2;
 800026c:	4b2f      	ldr	r3, [pc, #188]	; (800032c <main+0xec>)
 800026e:	4a30      	ldr	r2, [pc, #192]	; (8000330 <main+0xf0>)
 8000270:	609a      	str	r2, [r3, #8]

		// Set the stack pointer
		__set_MSP(*(ADDR_FLASH_SECTOR_2));
 8000272:	4b2f      	ldr	r3, [pc, #188]	; (8000330 <main+0xf0>)
 8000274:	681b      	ldr	r3, [r3, #0]
 8000276:	61fb      	str	r3, [r7, #28]
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 8000278:	69fb      	ldr	r3, [r7, #28]
 800027a:	f383 8808 	msr	MSP, r3
}
 800027e:	bf00      	nop

		// Go to the application
		p_application_function();
 8000280:	6a3b      	ldr	r3, [r7, #32]
 8000282:	4798      	blx	r3
 8000284:	e03c      	b.n	8000300 <main+0xc0>
	}
	else
	{
		// Unlock flash
		if (HAL_OK == HAL_FLASH_Unlock())
 8000286:	f000 f999 	bl	80005bc <HAL_FLASH_Unlock>
 800028a:	4603      	mov	r3, r0
 800028c:	2b00      	cmp	r3, #0
 800028e:	d137      	bne.n	8000300 <main+0xc0>
		{
			// Initialize erasing parameters to erase flash sector 2
			flash_erase.TypeErase    = FLASH_TYPEERASE_SECTORS;
 8000290:	2300      	movs	r3, #0
 8000292:	60bb      	str	r3, [r7, #8]
			flash_erase.Banks        = FLASH_BANK_1;
 8000294:	2301      	movs	r3, #1
 8000296:	60fb      	str	r3, [r7, #12]
			flash_erase.Sector       = FLASH_SECTOR_2;
 8000298:	2302      	movs	r3, #2
 800029a:	613b      	str	r3, [r7, #16]
			flash_erase.NbSectors    = 1;
 800029c:	2301      	movs	r3, #1
 800029e:	617b      	str	r3, [r7, #20]
			flash_erase.VoltageRange = FLASH_VOLTAGE_RANGE_1;
 80002a0:	2300      	movs	r3, #0
 80002a2:	61bb      	str	r3, [r7, #24]

			// Try to erase flash sector 2
			if (HAL_OK == HAL_FLASHEx_Erase(&flash_erase, &flash_sector_error))
 80002a4:	1d3a      	adds	r2, r7, #4
 80002a6:	f107 0308 	add.w	r3, r7, #8
 80002aa:	4611      	mov	r1, r2
 80002ac:	4618      	mov	r0, r3
 80002ae:	f000 fae7 	bl	8000880 <HAL_FLASHEx_Erase>
 80002b2:	4603      	mov	r3, r0
 80002b4:	2b00      	cmp	r3, #0
 80002b6:	d123      	bne.n	8000300 <main+0xc0>
			{
				for (index = 0U; index < 5156; index++)
 80002b8:	2300      	movs	r3, #0
 80002ba:	62fb      	str	r3, [r7, #44]	; 0x2c
 80002bc:	e01b      	b.n	80002f6 <main+0xb6>
				{
					// receive from USART
					rx_value = USART2_ReceiveChar();
 80002be:	f000 f8cb 	bl	8000458 <USART2_ReceiveChar>
 80002c2:	4603      	mov	r3, r0
 80002c4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

					// Print echo on USART
					USART2_TransmitChar(rx_value);
 80002c8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80002cc:	4618      	mov	r0, r3
 80002ce:	f000 f8ab 	bl	8000428 <USART2_TransmitChar>

					// Print the received paquet on the flash
					HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE,
 80002d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80002d4:	f103 6100 	add.w	r1, r3, #134217728	; 0x8000000
 80002d8:	f501 4100 	add.w	r1, r1, #32768	; 0x8000
 80002dc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80002e0:	2200      	movs	r2, #0
 80002e2:	461c      	mov	r4, r3
 80002e4:	4615      	mov	r5, r2
 80002e6:	4622      	mov	r2, r4
 80002e8:	462b      	mov	r3, r5
 80002ea:	2000      	movs	r0, #0
 80002ec:	f000 f912 	bl	8000514 <HAL_FLASH_Program>
				for (index = 0U; index < 5156; index++)
 80002f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80002f2:	3301      	adds	r3, #1
 80002f4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80002f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80002f8:	f241 4223 	movw	r2, #5155	; 0x1423
 80002fc:	4293      	cmp	r3, r2
 80002fe:	d9de      	bls.n	80002be <main+0x7e>

	// Infinite loop
	while(1)
	{
		// Bootloader code
		for(uint32_t i = 0 ; i<100000; i++);
 8000300:	2300      	movs	r3, #0
 8000302:	62bb      	str	r3, [r7, #40]	; 0x28
 8000304:	e002      	b.n	800030c <main+0xcc>
 8000306:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000308:	3301      	adds	r3, #1
 800030a:	62bb      	str	r3, [r7, #40]	; 0x28
 800030c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800030e:	4a09      	ldr	r2, [pc, #36]	; (8000334 <main+0xf4>)
 8000310:	4293      	cmp	r3, r2
 8000312:	d9f8      	bls.n	8000306 <main+0xc6>
		GPIOA->ODR ^= 1<<5;
 8000314:	4b08      	ldr	r3, [pc, #32]	; (8000338 <main+0xf8>)
 8000316:	695b      	ldr	r3, [r3, #20]
 8000318:	4a07      	ldr	r2, [pc, #28]	; (8000338 <main+0xf8>)
 800031a:	f083 0320 	eor.w	r3, r3, #32
 800031e:	6153      	str	r3, [r2, #20]
		for(uint32_t i = 0 ; i<100000; i++);
 8000320:	e7ee      	b.n	8000300 <main+0xc0>
 8000322:	bf00      	nop
 8000324:	08008004 	.word	0x08008004
 8000328:	40020800 	.word	0x40020800
 800032c:	e000ed00 	.word	0xe000ed00
 8000330:	08008000 	.word	0x08008000
 8000334:	0001869f 	.word	0x0001869f
 8000338:	40020000 	.word	0x40020000

0800033c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800033c:	b480      	push	{r7}
 800033e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8000340:	e7fe      	b.n	8000340 <NMI_Handler+0x4>

08000342 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8000342:	b480      	push	{r7}
 8000344:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8000346:	e7fe      	b.n	8000346 <HardFault_Handler+0x4>

08000348 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8000348:	b480      	push	{r7}
 800034a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800034c:	e7fe      	b.n	800034c <MemManage_Handler+0x4>

0800034e <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800034e:	b480      	push	{r7}
 8000350:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000352:	e7fe      	b.n	8000352 <BusFault_Handler+0x4>

08000354 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8000354:	b480      	push	{r7}
 8000356:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000358:	e7fe      	b.n	8000358 <UsageFault_Handler+0x4>

0800035a <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800035a:	b480      	push	{r7}
 800035c:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800035e:	bf00      	nop
 8000360:	46bd      	mov	sp, r7
 8000362:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000366:	4770      	bx	lr

08000368 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8000368:	b480      	push	{r7}
 800036a:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800036c:	bf00      	nop
 800036e:	46bd      	mov	sp, r7
 8000370:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000374:	4770      	bx	lr

08000376 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8000376:	b480      	push	{r7}
 8000378:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800037a:	bf00      	nop
 800037c:	46bd      	mov	sp, r7
 800037e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000382:	4770      	bx	lr

08000384 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8000384:	b580      	push	{r7, lr}
 8000386:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000388:	f000 f8a4 	bl	80004d4 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800038c:	bf00      	nop
 800038e:	bd80      	pop	{r7, pc}

08000390 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8000390:	b480      	push	{r7}
 8000392:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000394:	4b06      	ldr	r3, [pc, #24]	; (80003b0 <SystemInit+0x20>)
 8000396:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800039a:	4a05      	ldr	r2, [pc, #20]	; (80003b0 <SystemInit+0x20>)
 800039c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80003a0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 80003a4:	bf00      	nop
 80003a6:	46bd      	mov	sp, r7
 80003a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80003ac:	4770      	bx	lr
 80003ae:	bf00      	nop
 80003b0:	e000ed00 	.word	0xe000ed00

080003b4 <USART2_Init>:
#include <stm32f446xx.h>
#include "main.h"
#include "usart.h"


void USART2_Init(void){
 80003b4:	b480      	push	{r7}
 80003b6:	af00      	add	r7, sp, #0
	/* USART2 Init */
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;			// ABP1
 80003b8:	4b18      	ldr	r3, [pc, #96]	; (800041c <USART2_Init+0x68>)
 80003ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80003bc:	4a17      	ldr	r2, [pc, #92]	; (800041c <USART2_Init+0x68>)
 80003be:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80003c2:	6413      	str	r3, [r2, #64]	; 0x40
	GPIOA->MODER |= ALT_MODE<<4;					// PA2
 80003c4:	4b16      	ldr	r3, [pc, #88]	; (8000420 <USART2_Init+0x6c>)
 80003c6:	681b      	ldr	r3, [r3, #0]
 80003c8:	4a15      	ldr	r2, [pc, #84]	; (8000420 <USART2_Init+0x6c>)
 80003ca:	f043 0320 	orr.w	r3, r3, #32
 80003ce:	6013      	str	r3, [r2, #0]
	GPIOA->MODER |= ALT_MODE<<6;					// PA3
 80003d0:	4b13      	ldr	r3, [pc, #76]	; (8000420 <USART2_Init+0x6c>)
 80003d2:	681b      	ldr	r3, [r3, #0]
 80003d4:	4a12      	ldr	r2, [pc, #72]	; (8000420 <USART2_Init+0x6c>)
 80003d6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80003da:	6013      	str	r3, [r2, #0]
	GPIOA->AFR[0] |= 7<<8;							// USART2
 80003dc:	4b10      	ldr	r3, [pc, #64]	; (8000420 <USART2_Init+0x6c>)
 80003de:	6a1b      	ldr	r3, [r3, #32]
 80003e0:	4a0f      	ldr	r2, [pc, #60]	; (8000420 <USART2_Init+0x6c>)
 80003e2:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
 80003e6:	6213      	str	r3, [r2, #32]
	GPIOA->AFR[0] |= 7<<12;							// USART2
 80003e8:	4b0d      	ldr	r3, [pc, #52]	; (8000420 <USART2_Init+0x6c>)
 80003ea:	6a1b      	ldr	r3, [r3, #32]
 80003ec:	4a0c      	ldr	r2, [pc, #48]	; (8000420 <USART2_Init+0x6c>)
 80003ee:	f443 43e0 	orr.w	r3, r3, #28672	; 0x7000
 80003f2:	6213      	str	r3, [r2, #32]
	USART2->BRR  = 139;								// 115200 - APB1:16Mhz
 80003f4:	4b0b      	ldr	r3, [pc, #44]	; (8000424 <USART2_Init+0x70>)
 80003f6:	228b      	movs	r2, #139	; 0x8b
 80003f8:	609a      	str	r2, [r3, #8]
	USART2->CR1 |= USART_CR1_TE | USART_CR1_RE;		// RX-TX
 80003fa:	4b0a      	ldr	r3, [pc, #40]	; (8000424 <USART2_Init+0x70>)
 80003fc:	68db      	ldr	r3, [r3, #12]
 80003fe:	4a09      	ldr	r2, [pc, #36]	; (8000424 <USART2_Init+0x70>)
 8000400:	f043 030c 	orr.w	r3, r3, #12
 8000404:	60d3      	str	r3, [r2, #12]
	USART2->CR1 |= USART_CR1_UE;
 8000406:	4b07      	ldr	r3, [pc, #28]	; (8000424 <USART2_Init+0x70>)
 8000408:	68db      	ldr	r3, [r3, #12]
 800040a:	4a06      	ldr	r2, [pc, #24]	; (8000424 <USART2_Init+0x70>)
 800040c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000410:	60d3      	str	r3, [r2, #12]
}
 8000412:	bf00      	nop
 8000414:	46bd      	mov	sp, r7
 8000416:	f85d 7b04 	ldr.w	r7, [sp], #4
 800041a:	4770      	bx	lr
 800041c:	40023800 	.word	0x40023800
 8000420:	40020000 	.word	0x40020000
 8000424:	40004400 	.word	0x40004400

08000428 <USART2_TransmitChar>:


void USART2_TransmitChar(uint8_t data){
 8000428:	b480      	push	{r7}
 800042a:	b083      	sub	sp, #12
 800042c:	af00      	add	r7, sp, #0
 800042e:	4603      	mov	r3, r0
 8000430:	71fb      	strb	r3, [r7, #7]
	USART2->DR = data;
 8000432:	4a08      	ldr	r2, [pc, #32]	; (8000454 <USART2_TransmitChar+0x2c>)
 8000434:	79fb      	ldrb	r3, [r7, #7]
 8000436:	6053      	str	r3, [r2, #4]
	while( (USART2->SR & USART_SR_TXE)==0 );
 8000438:	bf00      	nop
 800043a:	4b06      	ldr	r3, [pc, #24]	; (8000454 <USART2_TransmitChar+0x2c>)
 800043c:	681b      	ldr	r3, [r3, #0]
 800043e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000442:	2b00      	cmp	r3, #0
 8000444:	d0f9      	beq.n	800043a <USART2_TransmitChar+0x12>
}
 8000446:	bf00      	nop
 8000448:	bf00      	nop
 800044a:	370c      	adds	r7, #12
 800044c:	46bd      	mov	sp, r7
 800044e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000452:	4770      	bx	lr
 8000454:	40004400 	.word	0x40004400

08000458 <USART2_ReceiveChar>:


uint8_t USART2_ReceiveChar(void){
 8000458:	b480      	push	{r7}
 800045a:	af00      	add	r7, sp, #0
	while( (USART2->SR & USART_SR_RXNE)==0 );
 800045c:	bf00      	nop
 800045e:	4b07      	ldr	r3, [pc, #28]	; (800047c <USART2_ReceiveChar+0x24>)
 8000460:	681b      	ldr	r3, [r3, #0]
 8000462:	f003 0320 	and.w	r3, r3, #32
 8000466:	2b00      	cmp	r3, #0
 8000468:	d0f9      	beq.n	800045e <USART2_ReceiveChar+0x6>
	return USART2->DR;
 800046a:	4b04      	ldr	r3, [pc, #16]	; (800047c <USART2_ReceiveChar+0x24>)
 800046c:	685b      	ldr	r3, [r3, #4]
 800046e:	b2db      	uxtb	r3, r3

}
 8000470:	4618      	mov	r0, r3
 8000472:	46bd      	mov	sp, r7
 8000474:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000478:	4770      	bx	lr
 800047a:	bf00      	nop
 800047c:	40004400 	.word	0x40004400

08000480 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8000480:	f8df d034 	ldr.w	sp, [pc, #52]	; 80004b8 <LoopFillZerobss+0x12>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8000484:	480d      	ldr	r0, [pc, #52]	; (80004bc <LoopFillZerobss+0x16>)
  ldr r1, =_edata
 8000486:	490e      	ldr	r1, [pc, #56]	; (80004c0 <LoopFillZerobss+0x1a>)
  ldr r2, =_sidata
 8000488:	4a0e      	ldr	r2, [pc, #56]	; (80004c4 <LoopFillZerobss+0x1e>)
  movs r3, #0
 800048a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800048c:	e002      	b.n	8000494 <LoopCopyDataInit>

0800048e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800048e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000490:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000492:	3304      	adds	r3, #4

08000494 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000494:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000496:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000498:	d3f9      	bcc.n	800048e <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800049a:	4a0b      	ldr	r2, [pc, #44]	; (80004c8 <LoopFillZerobss+0x22>)
  ldr r4, =_ebss
 800049c:	4c0b      	ldr	r4, [pc, #44]	; (80004cc <LoopFillZerobss+0x26>)
  movs r3, #0
 800049e:	2300      	movs	r3, #0
  b LoopFillZerobss
 80004a0:	e001      	b.n	80004a6 <LoopFillZerobss>

080004a2 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80004a2:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80004a4:	3204      	adds	r2, #4

080004a6 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80004a6:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80004a8:	d3fb      	bcc.n	80004a2 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 80004aa:	f7ff ff71 	bl	8000390 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80004ae:	f000 fb09 	bl	8000ac4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80004b2:	f7ff fec5 	bl	8000240 <main>
  bx  lr    
 80004b6:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 80004b8:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 80004bc:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80004c0:	20000004 	.word	0x20000004
  ldr r2, =_sidata
 80004c4:	08000b2c 	.word	0x08000b2c
  ldr r2, =_sbss
 80004c8:	20000004 	.word	0x20000004
  ldr r4, =_ebss
 80004cc:	20000044 	.word	0x20000044

080004d0 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80004d0:	e7fe      	b.n	80004d0 <ADC_IRQHandler>
	...

080004d4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 80004d4:	b480      	push	{r7}
 80004d6:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 80004d8:	4b06      	ldr	r3, [pc, #24]	; (80004f4 <HAL_IncTick+0x20>)
 80004da:	781b      	ldrb	r3, [r3, #0]
 80004dc:	461a      	mov	r2, r3
 80004de:	4b06      	ldr	r3, [pc, #24]	; (80004f8 <HAL_IncTick+0x24>)
 80004e0:	681b      	ldr	r3, [r3, #0]
 80004e2:	4413      	add	r3, r2
 80004e4:	4a04      	ldr	r2, [pc, #16]	; (80004f8 <HAL_IncTick+0x24>)
 80004e6:	6013      	str	r3, [r2, #0]
}
 80004e8:	bf00      	nop
 80004ea:	46bd      	mov	sp, r7
 80004ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80004f0:	4770      	bx	lr
 80004f2:	bf00      	nop
 80004f4:	20000000 	.word	0x20000000
 80004f8:	20000020 	.word	0x20000020

080004fc <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80004fc:	b480      	push	{r7}
 80004fe:	af00      	add	r7, sp, #0
  return uwTick;
 8000500:	4b03      	ldr	r3, [pc, #12]	; (8000510 <HAL_GetTick+0x14>)
 8000502:	681b      	ldr	r3, [r3, #0]
}
 8000504:	4618      	mov	r0, r3
 8000506:	46bd      	mov	sp, r7
 8000508:	f85d 7b04 	ldr.w	r7, [sp], #4
 800050c:	4770      	bx	lr
 800050e:	bf00      	nop
 8000510:	20000020 	.word	0x20000020

08000514 <HAL_FLASH_Program>:
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8000514:	b580      	push	{r7, lr}
 8000516:	b086      	sub	sp, #24
 8000518:	af00      	add	r7, sp, #0
 800051a:	60f8      	str	r0, [r7, #12]
 800051c:	60b9      	str	r1, [r7, #8]
 800051e:	e9c7 2300 	strd	r2, r3, [r7]
  HAL_StatusTypeDef status = HAL_ERROR;
 8000522:	2301      	movs	r3, #1
 8000524:	75fb      	strb	r3, [r7, #23]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8000526:	4b23      	ldr	r3, [pc, #140]	; (80005b4 <HAL_FLASH_Program+0xa0>)
 8000528:	7e1b      	ldrb	r3, [r3, #24]
 800052a:	2b01      	cmp	r3, #1
 800052c:	d101      	bne.n	8000532 <HAL_FLASH_Program+0x1e>
 800052e:	2302      	movs	r3, #2
 8000530:	e03b      	b.n	80005aa <HAL_FLASH_Program+0x96>
 8000532:	4b20      	ldr	r3, [pc, #128]	; (80005b4 <HAL_FLASH_Program+0xa0>)
 8000534:	2201      	movs	r2, #1
 8000536:	761a      	strb	r2, [r3, #24]
  
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8000538:	f24c 3050 	movw	r0, #50000	; 0xc350
 800053c:	f000 f860 	bl	8000600 <FLASH_WaitForLastOperation>
 8000540:	4603      	mov	r3, r0
 8000542:	75fb      	strb	r3, [r7, #23]
  
  if(status == HAL_OK)
 8000544:	7dfb      	ldrb	r3, [r7, #23]
 8000546:	2b00      	cmp	r3, #0
 8000548:	d12b      	bne.n	80005a2 <HAL_FLASH_Program+0x8e>
  {
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
 800054a:	68fb      	ldr	r3, [r7, #12]
 800054c:	2b00      	cmp	r3, #0
 800054e:	d105      	bne.n	800055c <HAL_FLASH_Program+0x48>
    {
      /*Program byte (8-bit) at a specified address.*/
      FLASH_Program_Byte(Address, (uint8_t) Data);
 8000550:	783b      	ldrb	r3, [r7, #0]
 8000552:	4619      	mov	r1, r3
 8000554:	68b8      	ldr	r0, [r7, #8]
 8000556:	f000 f90b 	bl	8000770 <FLASH_Program_Byte>
 800055a:	e016      	b.n	800058a <HAL_FLASH_Program+0x76>
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 800055c:	68fb      	ldr	r3, [r7, #12]
 800055e:	2b01      	cmp	r3, #1
 8000560:	d105      	bne.n	800056e <HAL_FLASH_Program+0x5a>
    {
      /*Program halfword (16-bit) at a specified address.*/
      FLASH_Program_HalfWord(Address, (uint16_t) Data);
 8000562:	883b      	ldrh	r3, [r7, #0]
 8000564:	4619      	mov	r1, r3
 8000566:	68b8      	ldr	r0, [r7, #8]
 8000568:	f000 f8de 	bl	8000728 <FLASH_Program_HalfWord>
 800056c:	e00d      	b.n	800058a <HAL_FLASH_Program+0x76>
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 800056e:	68fb      	ldr	r3, [r7, #12]
 8000570:	2b02      	cmp	r3, #2
 8000572:	d105      	bne.n	8000580 <HAL_FLASH_Program+0x6c>
    {
      /*Program word (32-bit) at a specified address.*/
      FLASH_Program_Word(Address, (uint32_t) Data);
 8000574:	683b      	ldr	r3, [r7, #0]
 8000576:	4619      	mov	r1, r3
 8000578:	68b8      	ldr	r0, [r7, #8]
 800057a:	f000 f8b3 	bl	80006e4 <FLASH_Program_Word>
 800057e:	e004      	b.n	800058a <HAL_FLASH_Program+0x76>
    }
    else
    {
      /*Program double word (64-bit) at a specified address.*/
      FLASH_Program_DoubleWord(Address, Data);
 8000580:	e9d7 2300 	ldrd	r2, r3, [r7]
 8000584:	68b8      	ldr	r0, [r7, #8]
 8000586:	f000 f87b 	bl	8000680 <FLASH_Program_DoubleWord>
    }
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800058a:	f24c 3050 	movw	r0, #50000	; 0xc350
 800058e:	f000 f837 	bl	8000600 <FLASH_WaitForLastOperation>
 8000592:	4603      	mov	r3, r0
 8000594:	75fb      	strb	r3, [r7, #23]
    
    /* If the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);  
 8000596:	4b08      	ldr	r3, [pc, #32]	; (80005b8 <HAL_FLASH_Program+0xa4>)
 8000598:	691b      	ldr	r3, [r3, #16]
 800059a:	4a07      	ldr	r2, [pc, #28]	; (80005b8 <HAL_FLASH_Program+0xa4>)
 800059c:	f023 0301 	bic.w	r3, r3, #1
 80005a0:	6113      	str	r3, [r2, #16]
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 80005a2:	4b04      	ldr	r3, [pc, #16]	; (80005b4 <HAL_FLASH_Program+0xa0>)
 80005a4:	2200      	movs	r2, #0
 80005a6:	761a      	strb	r2, [r3, #24]
  
  return status;
 80005a8:	7dfb      	ldrb	r3, [r7, #23]
}
 80005aa:	4618      	mov	r0, r3
 80005ac:	3718      	adds	r7, #24
 80005ae:	46bd      	mov	sp, r7
 80005b0:	bd80      	pop	{r7, pc}
 80005b2:	bf00      	nop
 80005b4:	20000024 	.word	0x20000024
 80005b8:	40023c00 	.word	0x40023c00

080005bc <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
 80005bc:	b480      	push	{r7}
 80005be:	b083      	sub	sp, #12
 80005c0:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 80005c2:	2300      	movs	r3, #0
 80005c4:	71fb      	strb	r3, [r7, #7]

  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 80005c6:	4b0b      	ldr	r3, [pc, #44]	; (80005f4 <HAL_FLASH_Unlock+0x38>)
 80005c8:	691b      	ldr	r3, [r3, #16]
 80005ca:	2b00      	cmp	r3, #0
 80005cc:	da0b      	bge.n	80005e6 <HAL_FLASH_Unlock+0x2a>
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 80005ce:	4b09      	ldr	r3, [pc, #36]	; (80005f4 <HAL_FLASH_Unlock+0x38>)
 80005d0:	4a09      	ldr	r2, [pc, #36]	; (80005f8 <HAL_FLASH_Unlock+0x3c>)
 80005d2:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 80005d4:	4b07      	ldr	r3, [pc, #28]	; (80005f4 <HAL_FLASH_Unlock+0x38>)
 80005d6:	4a09      	ldr	r2, [pc, #36]	; (80005fc <HAL_FLASH_Unlock+0x40>)
 80005d8:	605a      	str	r2, [r3, #4]

    /* Verify Flash is unlocked */
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 80005da:	4b06      	ldr	r3, [pc, #24]	; (80005f4 <HAL_FLASH_Unlock+0x38>)
 80005dc:	691b      	ldr	r3, [r3, #16]
 80005de:	2b00      	cmp	r3, #0
 80005e0:	da01      	bge.n	80005e6 <HAL_FLASH_Unlock+0x2a>
    {
      status = HAL_ERROR;
 80005e2:	2301      	movs	r3, #1
 80005e4:	71fb      	strb	r3, [r7, #7]
    }
  }

  return status;
 80005e6:	79fb      	ldrb	r3, [r7, #7]
}
 80005e8:	4618      	mov	r0, r3
 80005ea:	370c      	adds	r7, #12
 80005ec:	46bd      	mov	sp, r7
 80005ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80005f2:	4770      	bx	lr
 80005f4:	40023c00 	.word	0x40023c00
 80005f8:	45670123 	.word	0x45670123
 80005fc:	cdef89ab 	.word	0xcdef89ab

08000600 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operationtimeout
  * @retval HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
 8000600:	b580      	push	{r7, lr}
 8000602:	b084      	sub	sp, #16
 8000604:	af00      	add	r7, sp, #0
 8000606:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8000608:	2300      	movs	r3, #0
 800060a:	60fb      	str	r3, [r7, #12]
  
  /* Clear Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800060c:	4b1a      	ldr	r3, [pc, #104]	; (8000678 <FLASH_WaitForLastOperation+0x78>)
 800060e:	2200      	movs	r2, #0
 8000610:	61da      	str	r2, [r3, #28]
  
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  /* Get tick */
  tickstart = HAL_GetTick();
 8000612:	f7ff ff73 	bl	80004fc <HAL_GetTick>
 8000616:	60f8      	str	r0, [r7, #12]

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8000618:	e010      	b.n	800063c <FLASH_WaitForLastOperation+0x3c>
  { 
    if(Timeout != HAL_MAX_DELAY)
 800061a:	687b      	ldr	r3, [r7, #4]
 800061c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000620:	d00c      	beq.n	800063c <FLASH_WaitForLastOperation+0x3c>
    {
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8000622:	687b      	ldr	r3, [r7, #4]
 8000624:	2b00      	cmp	r3, #0
 8000626:	d007      	beq.n	8000638 <FLASH_WaitForLastOperation+0x38>
 8000628:	f7ff ff68 	bl	80004fc <HAL_GetTick>
 800062c:	4602      	mov	r2, r0
 800062e:	68fb      	ldr	r3, [r7, #12]
 8000630:	1ad3      	subs	r3, r2, r3
 8000632:	687a      	ldr	r2, [r7, #4]
 8000634:	429a      	cmp	r2, r3
 8000636:	d201      	bcs.n	800063c <FLASH_WaitForLastOperation+0x3c>
      {
        return HAL_TIMEOUT;
 8000638:	2303      	movs	r3, #3
 800063a:	e019      	b.n	8000670 <FLASH_WaitForLastOperation+0x70>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 800063c:	4b0f      	ldr	r3, [pc, #60]	; (800067c <FLASH_WaitForLastOperation+0x7c>)
 800063e:	68db      	ldr	r3, [r3, #12]
 8000640:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000644:	2b00      	cmp	r3, #0
 8000646:	d1e8      	bne.n	800061a <FLASH_WaitForLastOperation+0x1a>
      }
    } 
  }

  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8000648:	4b0c      	ldr	r3, [pc, #48]	; (800067c <FLASH_WaitForLastOperation+0x7c>)
 800064a:	68db      	ldr	r3, [r3, #12]
 800064c:	f003 0301 	and.w	r3, r3, #1
 8000650:	2b00      	cmp	r3, #0
 8000652:	d002      	beq.n	800065a <FLASH_WaitForLastOperation+0x5a>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8000654:	4b09      	ldr	r3, [pc, #36]	; (800067c <FLASH_WaitForLastOperation+0x7c>)
 8000656:	2201      	movs	r2, #1
 8000658:	60da      	str	r2, [r3, #12]
  }
#if defined(FLASH_SR_RDERR)  
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 800065a:	4b08      	ldr	r3, [pc, #32]	; (800067c <FLASH_WaitForLastOperation+0x7c>)
 800065c:	68db      	ldr	r3, [r3, #12]
 800065e:	f403 73f9 	and.w	r3, r3, #498	; 0x1f2
 8000662:	2b00      	cmp	r3, #0
 8000664:	d003      	beq.n	800066e <FLASH_WaitForLastOperation+0x6e>
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
                           FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)) != RESET)
#endif /* FLASH_SR_RDERR */
  {
    /*Save the error code*/
    FLASH_SetErrorCode();
 8000666:	f000 f8a5 	bl	80007b4 <FLASH_SetErrorCode>
    return HAL_ERROR;
 800066a:	2301      	movs	r3, #1
 800066c:	e000      	b.n	8000670 <FLASH_WaitForLastOperation+0x70>
  }

  /* If there is no error flag set */
  return HAL_OK;
 800066e:	2300      	movs	r3, #0
  
}  
 8000670:	4618      	mov	r0, r3
 8000672:	3710      	adds	r7, #16
 8000674:	46bd      	mov	sp, r7
 8000676:	bd80      	pop	{r7, pc}
 8000678:	20000024 	.word	0x20000024
 800067c:	40023c00 	.word	0x40023c00

08000680 <FLASH_Program_DoubleWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 8000680:	b480      	push	{r7}
 8000682:	b085      	sub	sp, #20
 8000684:	af00      	add	r7, sp, #0
 8000686:	60f8      	str	r0, [r7, #12]
 8000688:	e9c7 2300 	strd	r2, r3, [r7]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 800068c:	4b14      	ldr	r3, [pc, #80]	; (80006e0 <FLASH_Program_DoubleWord+0x60>)
 800068e:	691b      	ldr	r3, [r3, #16]
 8000690:	4a13      	ldr	r2, [pc, #76]	; (80006e0 <FLASH_Program_DoubleWord+0x60>)
 8000692:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000696:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8000698:	4b11      	ldr	r3, [pc, #68]	; (80006e0 <FLASH_Program_DoubleWord+0x60>)
 800069a:	691b      	ldr	r3, [r3, #16]
 800069c:	4a10      	ldr	r2, [pc, #64]	; (80006e0 <FLASH_Program_DoubleWord+0x60>)
 800069e:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 80006a2:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 80006a4:	4b0e      	ldr	r3, [pc, #56]	; (80006e0 <FLASH_Program_DoubleWord+0x60>)
 80006a6:	691b      	ldr	r3, [r3, #16]
 80006a8:	4a0d      	ldr	r2, [pc, #52]	; (80006e0 <FLASH_Program_DoubleWord+0x60>)
 80006aa:	f043 0301 	orr.w	r3, r3, #1
 80006ae:	6113      	str	r3, [r2, #16]

  /* Program first word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
 80006b0:	68fb      	ldr	r3, [r7, #12]
 80006b2:	683a      	ldr	r2, [r7, #0]
 80006b4:	601a      	str	r2, [r3, #0]
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80006b6:	f3bf 8f6f 	isb	sy
}
 80006ba:	bf00      	nop
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 80006bc:	e9d7 0100 	ldrd	r0, r1, [r7]
 80006c0:	f04f 0200 	mov.w	r2, #0
 80006c4:	f04f 0300 	mov.w	r3, #0
 80006c8:	000a      	movs	r2, r1
 80006ca:	2300      	movs	r3, #0
 80006cc:	68f9      	ldr	r1, [r7, #12]
 80006ce:	3104      	adds	r1, #4
 80006d0:	4613      	mov	r3, r2
 80006d2:	600b      	str	r3, [r1, #0]
}
 80006d4:	bf00      	nop
 80006d6:	3714      	adds	r7, #20
 80006d8:	46bd      	mov	sp, r7
 80006da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80006de:	4770      	bx	lr
 80006e0:	40023c00 	.word	0x40023c00

080006e4 <FLASH_Program_Word>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
{
 80006e4:	b480      	push	{r7}
 80006e6:	b083      	sub	sp, #12
 80006e8:	af00      	add	r7, sp, #0
 80006ea:	6078      	str	r0, [r7, #4]
 80006ec:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 80006ee:	4b0d      	ldr	r3, [pc, #52]	; (8000724 <FLASH_Program_Word+0x40>)
 80006f0:	691b      	ldr	r3, [r3, #16]
 80006f2:	4a0c      	ldr	r2, [pc, #48]	; (8000724 <FLASH_Program_Word+0x40>)
 80006f4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80006f8:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
 80006fa:	4b0a      	ldr	r3, [pc, #40]	; (8000724 <FLASH_Program_Word+0x40>)
 80006fc:	691b      	ldr	r3, [r3, #16]
 80006fe:	4a09      	ldr	r2, [pc, #36]	; (8000724 <FLASH_Program_Word+0x40>)
 8000700:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000704:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8000706:	4b07      	ldr	r3, [pc, #28]	; (8000724 <FLASH_Program_Word+0x40>)
 8000708:	691b      	ldr	r3, [r3, #16]
 800070a:	4a06      	ldr	r2, [pc, #24]	; (8000724 <FLASH_Program_Word+0x40>)
 800070c:	f043 0301 	orr.w	r3, r3, #1
 8000710:	6113      	str	r3, [r2, #16]

  *(__IO uint32_t*)Address = Data;
 8000712:	687b      	ldr	r3, [r7, #4]
 8000714:	683a      	ldr	r2, [r7, #0]
 8000716:	601a      	str	r2, [r3, #0]
}
 8000718:	bf00      	nop
 800071a:	370c      	adds	r7, #12
 800071c:	46bd      	mov	sp, r7
 800071e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000722:	4770      	bx	lr
 8000724:	40023c00 	.word	0x40023c00

08000728 <FLASH_Program_HalfWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
{
 8000728:	b480      	push	{r7}
 800072a:	b083      	sub	sp, #12
 800072c:	af00      	add	r7, sp, #0
 800072e:	6078      	str	r0, [r7, #4]
 8000730:	460b      	mov	r3, r1
 8000732:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8000734:	4b0d      	ldr	r3, [pc, #52]	; (800076c <FLASH_Program_HalfWord+0x44>)
 8000736:	691b      	ldr	r3, [r3, #16]
 8000738:	4a0c      	ldr	r2, [pc, #48]	; (800076c <FLASH_Program_HalfWord+0x44>)
 800073a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800073e:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 8000740:	4b0a      	ldr	r3, [pc, #40]	; (800076c <FLASH_Program_HalfWord+0x44>)
 8000742:	691b      	ldr	r3, [r3, #16]
 8000744:	4a09      	ldr	r2, [pc, #36]	; (800076c <FLASH_Program_HalfWord+0x44>)
 8000746:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800074a:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 800074c:	4b07      	ldr	r3, [pc, #28]	; (800076c <FLASH_Program_HalfWord+0x44>)
 800074e:	691b      	ldr	r3, [r3, #16]
 8000750:	4a06      	ldr	r2, [pc, #24]	; (800076c <FLASH_Program_HalfWord+0x44>)
 8000752:	f043 0301 	orr.w	r3, r3, #1
 8000756:	6113      	str	r3, [r2, #16]

  *(__IO uint16_t*)Address = Data;
 8000758:	687b      	ldr	r3, [r7, #4]
 800075a:	887a      	ldrh	r2, [r7, #2]
 800075c:	801a      	strh	r2, [r3, #0]
}
 800075e:	bf00      	nop
 8000760:	370c      	adds	r7, #12
 8000762:	46bd      	mov	sp, r7
 8000764:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000768:	4770      	bx	lr
 800076a:	bf00      	nop
 800076c:	40023c00 	.word	0x40023c00

08000770 <FLASH_Program_Byte>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
{
 8000770:	b480      	push	{r7}
 8000772:	b083      	sub	sp, #12
 8000774:	af00      	add	r7, sp, #0
 8000776:	6078      	str	r0, [r7, #4]
 8000778:	460b      	mov	r3, r1
 800077a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 800077c:	4b0c      	ldr	r3, [pc, #48]	; (80007b0 <FLASH_Program_Byte+0x40>)
 800077e:	691b      	ldr	r3, [r3, #16]
 8000780:	4a0b      	ldr	r2, [pc, #44]	; (80007b0 <FLASH_Program_Byte+0x40>)
 8000782:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000786:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 8000788:	4b09      	ldr	r3, [pc, #36]	; (80007b0 <FLASH_Program_Byte+0x40>)
 800078a:	4a09      	ldr	r2, [pc, #36]	; (80007b0 <FLASH_Program_Byte+0x40>)
 800078c:	691b      	ldr	r3, [r3, #16]
 800078e:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8000790:	4b07      	ldr	r3, [pc, #28]	; (80007b0 <FLASH_Program_Byte+0x40>)
 8000792:	691b      	ldr	r3, [r3, #16]
 8000794:	4a06      	ldr	r2, [pc, #24]	; (80007b0 <FLASH_Program_Byte+0x40>)
 8000796:	f043 0301 	orr.w	r3, r3, #1
 800079a:	6113      	str	r3, [r2, #16]

  *(__IO uint8_t*)Address = Data;
 800079c:	687b      	ldr	r3, [r7, #4]
 800079e:	78fa      	ldrb	r2, [r7, #3]
 80007a0:	701a      	strb	r2, [r3, #0]
}
 80007a2:	bf00      	nop
 80007a4:	370c      	adds	r7, #12
 80007a6:	46bd      	mov	sp, r7
 80007a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007ac:	4770      	bx	lr
 80007ae:	bf00      	nop
 80007b0:	40023c00 	.word	0x40023c00

080007b4 <FLASH_SetErrorCode>:
/**
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{ 
 80007b4:	b480      	push	{r7}
 80007b6:	af00      	add	r7, sp, #0
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 80007b8:	4b2f      	ldr	r3, [pc, #188]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 80007ba:	68db      	ldr	r3, [r3, #12]
 80007bc:	f003 0310 	and.w	r3, r3, #16
 80007c0:	2b00      	cmp	r3, #0
 80007c2:	d008      	beq.n	80007d6 <FLASH_SetErrorCode+0x22>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 80007c4:	4b2d      	ldr	r3, [pc, #180]	; (800087c <FLASH_SetErrorCode+0xc8>)
 80007c6:	69db      	ldr	r3, [r3, #28]
 80007c8:	f043 0310 	orr.w	r3, r3, #16
 80007cc:	4a2b      	ldr	r2, [pc, #172]	; (800087c <FLASH_SetErrorCode+0xc8>)
 80007ce:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH write protection error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
 80007d0:	4b29      	ldr	r3, [pc, #164]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 80007d2:	2210      	movs	r2, #16
 80007d4:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 80007d6:	4b28      	ldr	r3, [pc, #160]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 80007d8:	68db      	ldr	r3, [r3, #12]
 80007da:	f003 0320 	and.w	r3, r3, #32
 80007de:	2b00      	cmp	r3, #0
 80007e0:	d008      	beq.n	80007f4 <FLASH_SetErrorCode+0x40>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 80007e2:	4b26      	ldr	r3, [pc, #152]	; (800087c <FLASH_SetErrorCode+0xc8>)
 80007e4:	69db      	ldr	r3, [r3, #28]
 80007e6:	f043 0308 	orr.w	r3, r3, #8
 80007ea:	4a24      	ldr	r2, [pc, #144]	; (800087c <FLASH_SetErrorCode+0xc8>)
 80007ec:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH Programming alignment error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
 80007ee:	4b22      	ldr	r3, [pc, #136]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 80007f0:	2220      	movs	r2, #32
 80007f2:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 80007f4:	4b20      	ldr	r3, [pc, #128]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 80007f6:	68db      	ldr	r3, [r3, #12]
 80007f8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80007fc:	2b00      	cmp	r3, #0
 80007fe:	d008      	beq.n	8000812 <FLASH_SetErrorCode+0x5e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8000800:	4b1e      	ldr	r3, [pc, #120]	; (800087c <FLASH_SetErrorCode+0xc8>)
 8000802:	69db      	ldr	r3, [r3, #28]
 8000804:	f043 0304 	orr.w	r3, r3, #4
 8000808:	4a1c      	ldr	r2, [pc, #112]	; (800087c <FLASH_SetErrorCode+0xc8>)
 800080a:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming parallelism error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
 800080c:	4b1a      	ldr	r3, [pc, #104]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 800080e:	2240      	movs	r2, #64	; 0x40
 8000810:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
 8000812:	4b19      	ldr	r3, [pc, #100]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 8000814:	68db      	ldr	r3, [r3, #12]
 8000816:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800081a:	2b00      	cmp	r3, #0
 800081c:	d008      	beq.n	8000830 <FLASH_SetErrorCode+0x7c>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 800081e:	4b17      	ldr	r3, [pc, #92]	; (800087c <FLASH_SetErrorCode+0xc8>)
 8000820:	69db      	ldr	r3, [r3, #28]
 8000822:	f043 0302 	orr.w	r3, r3, #2
 8000826:	4a15      	ldr	r2, [pc, #84]	; (800087c <FLASH_SetErrorCode+0xc8>)
 8000828:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming sequence error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
 800082a:	4b13      	ldr	r3, [pc, #76]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 800082c:	2280      	movs	r2, #128	; 0x80
 800082e:	60da      	str	r2, [r3, #12]
  }
#if defined(FLASH_SR_RDERR) 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
 8000830:	4b11      	ldr	r3, [pc, #68]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 8000832:	68db      	ldr	r3, [r3, #12]
 8000834:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8000838:	2b00      	cmp	r3, #0
 800083a:	d009      	beq.n	8000850 <FLASH_SetErrorCode+0x9c>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
 800083c:	4b0f      	ldr	r3, [pc, #60]	; (800087c <FLASH_SetErrorCode+0xc8>)
 800083e:	69db      	ldr	r3, [r3, #28]
 8000840:	f043 0301 	orr.w	r3, r3, #1
 8000844:	4a0d      	ldr	r2, [pc, #52]	; (800087c <FLASH_SetErrorCode+0xc8>)
 8000846:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Proprietary readout protection error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
 8000848:	4b0b      	ldr	r3, [pc, #44]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 800084a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800084e:	60da      	str	r2, [r3, #12]
  }
#endif /* FLASH_SR_RDERR */  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8000850:	4b09      	ldr	r3, [pc, #36]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 8000852:	68db      	ldr	r3, [r3, #12]
 8000854:	f003 0302 	and.w	r3, r3, #2
 8000858:	2b00      	cmp	r3, #0
 800085a:	d008      	beq.n	800086e <FLASH_SetErrorCode+0xba>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 800085c:	4b07      	ldr	r3, [pc, #28]	; (800087c <FLASH_SetErrorCode+0xc8>)
 800085e:	69db      	ldr	r3, [r3, #28]
 8000860:	f043 0320 	orr.w	r3, r3, #32
 8000864:	4a05      	ldr	r2, [pc, #20]	; (800087c <FLASH_SetErrorCode+0xc8>)
 8000866:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Operation error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
 8000868:	4b03      	ldr	r3, [pc, #12]	; (8000878 <FLASH_SetErrorCode+0xc4>)
 800086a:	2202      	movs	r2, #2
 800086c:	60da      	str	r2, [r3, #12]
  }
}
 800086e:	bf00      	nop
 8000870:	46bd      	mov	sp, r7
 8000872:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000876:	4770      	bx	lr
 8000878:	40023c00 	.word	0x40023c00
 800087c:	20000024 	.word	0x20000024

08000880 <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFFU means that all the sectors have been correctly erased)
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
 8000880:	b580      	push	{r7, lr}
 8000882:	b084      	sub	sp, #16
 8000884:	af00      	add	r7, sp, #0
 8000886:	6078      	str	r0, [r7, #4]
 8000888:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_ERROR;
 800088a:	2301      	movs	r3, #1
 800088c:	73fb      	strb	r3, [r7, #15]
  uint32_t index = 0U;
 800088e:	2300      	movs	r3, #0
 8000890:	60bb      	str	r3, [r7, #8]

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8000892:	4b31      	ldr	r3, [pc, #196]	; (8000958 <HAL_FLASHEx_Erase+0xd8>)
 8000894:	7e1b      	ldrb	r3, [r3, #24]
 8000896:	2b01      	cmp	r3, #1
 8000898:	d101      	bne.n	800089e <HAL_FLASHEx_Erase+0x1e>
 800089a:	2302      	movs	r3, #2
 800089c:	e058      	b.n	8000950 <HAL_FLASHEx_Erase+0xd0>
 800089e:	4b2e      	ldr	r3, [pc, #184]	; (8000958 <HAL_FLASHEx_Erase+0xd8>)
 80008a0:	2201      	movs	r2, #1
 80008a2:	761a      	strb	r2, [r3, #24]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80008a4:	f24c 3050 	movw	r0, #50000	; 0xc350
 80008a8:	f7ff feaa 	bl	8000600 <FLASH_WaitForLastOperation>
 80008ac:	4603      	mov	r3, r0
 80008ae:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
 80008b0:	7bfb      	ldrb	r3, [r7, #15]
 80008b2:	2b00      	cmp	r3, #0
 80008b4:	d148      	bne.n	8000948 <HAL_FLASHEx_Erase+0xc8>
  {
    /*Initialization of SectorError variable*/
    *SectorError = 0xFFFFFFFFU;
 80008b6:	683b      	ldr	r3, [r7, #0]
 80008b8:	f04f 32ff 	mov.w	r2, #4294967295
 80008bc:	601a      	str	r2, [r3, #0]

    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 80008be:	687b      	ldr	r3, [r7, #4]
 80008c0:	681b      	ldr	r3, [r3, #0]
 80008c2:	2b01      	cmp	r3, #1
 80008c4:	d115      	bne.n	80008f2 <HAL_FLASHEx_Erase+0x72>
    {
      /*Mass erase to be done*/
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
 80008c6:	687b      	ldr	r3, [r7, #4]
 80008c8:	691b      	ldr	r3, [r3, #16]
 80008ca:	b2da      	uxtb	r2, r3
 80008cc:	687b      	ldr	r3, [r7, #4]
 80008ce:	685b      	ldr	r3, [r3, #4]
 80008d0:	4619      	mov	r1, r3
 80008d2:	4610      	mov	r0, r2
 80008d4:	f000 f844 	bl	8000960 <FLASH_MassErase>

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80008d8:	f24c 3050 	movw	r0, #50000	; 0xc350
 80008dc:	f7ff fe90 	bl	8000600 <FLASH_WaitForLastOperation>
 80008e0:	4603      	mov	r3, r0
 80008e2:	73fb      	strb	r3, [r7, #15]

      /* if the erase operation is completed, disable the MER Bit */
      FLASH->CR &= (~FLASH_MER_BIT);
 80008e4:	4b1d      	ldr	r3, [pc, #116]	; (800095c <HAL_FLASHEx_Erase+0xdc>)
 80008e6:	691b      	ldr	r3, [r3, #16]
 80008e8:	4a1c      	ldr	r2, [pc, #112]	; (800095c <HAL_FLASHEx_Erase+0xdc>)
 80008ea:	f023 0304 	bic.w	r3, r3, #4
 80008ee:	6113      	str	r3, [r2, #16]
 80008f0:	e028      	b.n	8000944 <HAL_FLASHEx_Erase+0xc4>
    {
      /* Check the parameters */
      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));

      /* Erase by sector by sector to be done*/
      for (index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 80008f2:	687b      	ldr	r3, [r7, #4]
 80008f4:	689b      	ldr	r3, [r3, #8]
 80008f6:	60bb      	str	r3, [r7, #8]
 80008f8:	e01c      	b.n	8000934 <HAL_FLASHEx_Erase+0xb4>
      {
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
 80008fa:	687b      	ldr	r3, [r7, #4]
 80008fc:	691b      	ldr	r3, [r3, #16]
 80008fe:	b2db      	uxtb	r3, r3
 8000900:	4619      	mov	r1, r3
 8000902:	68b8      	ldr	r0, [r7, #8]
 8000904:	f000 f850 	bl	80009a8 <FLASH_Erase_Sector>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8000908:	f24c 3050 	movw	r0, #50000	; 0xc350
 800090c:	f7ff fe78 	bl	8000600 <FLASH_WaitForLastOperation>
 8000910:	4603      	mov	r3, r0
 8000912:	73fb      	strb	r3, [r7, #15]

        /* If the erase operation is completed, disable the SER and SNB Bits */
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
 8000914:	4b11      	ldr	r3, [pc, #68]	; (800095c <HAL_FLASHEx_Erase+0xdc>)
 8000916:	691b      	ldr	r3, [r3, #16]
 8000918:	4a10      	ldr	r2, [pc, #64]	; (800095c <HAL_FLASHEx_Erase+0xdc>)
 800091a:	f023 03fa 	bic.w	r3, r3, #250	; 0xfa
 800091e:	6113      	str	r3, [r2, #16]

        if (status != HAL_OK)
 8000920:	7bfb      	ldrb	r3, [r7, #15]
 8000922:	2b00      	cmp	r3, #0
 8000924:	d003      	beq.n	800092e <HAL_FLASHEx_Erase+0xae>
        {
          /* In case of error, stop erase procedure and return the faulty sector*/
          *SectorError = index;
 8000926:	683b      	ldr	r3, [r7, #0]
 8000928:	68ba      	ldr	r2, [r7, #8]
 800092a:	601a      	str	r2, [r3, #0]
          break;
 800092c:	e00a      	b.n	8000944 <HAL_FLASHEx_Erase+0xc4>
      for (index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 800092e:	68bb      	ldr	r3, [r7, #8]
 8000930:	3301      	adds	r3, #1
 8000932:	60bb      	str	r3, [r7, #8]
 8000934:	687b      	ldr	r3, [r7, #4]
 8000936:	68da      	ldr	r2, [r3, #12]
 8000938:	687b      	ldr	r3, [r7, #4]
 800093a:	689b      	ldr	r3, [r3, #8]
 800093c:	4413      	add	r3, r2
 800093e:	68ba      	ldr	r2, [r7, #8]
 8000940:	429a      	cmp	r2, r3
 8000942:	d3da      	bcc.n	80008fa <HAL_FLASHEx_Erase+0x7a>
        }
      }
    }
    /* Flush the caches to be sure of the data consistency */
    FLASH_FlushCaches();
 8000944:	f000 f878 	bl	8000a38 <FLASH_FlushCaches>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 8000948:	4b03      	ldr	r3, [pc, #12]	; (8000958 <HAL_FLASHEx_Erase+0xd8>)
 800094a:	2200      	movs	r2, #0
 800094c:	761a      	strb	r2, [r3, #24]

  return status;
 800094e:	7bfb      	ldrb	r3, [r7, #15]
}
 8000950:	4618      	mov	r0, r3
 8000952:	3710      	adds	r7, #16
 8000954:	46bd      	mov	sp, r7
 8000956:	bd80      	pop	{r7, pc}
 8000958:	20000024 	.word	0x20000024
 800095c:	40023c00 	.word	0x40023c00

08000960 <FLASH_MassErase>:
  *            @arg FLASH_BANK_1: Bank1 to be erased
  *
  * @retval None
  */
static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)
{
 8000960:	b480      	push	{r7}
 8000962:	b083      	sub	sp, #12
 8000964:	af00      	add	r7, sp, #0
 8000966:	4603      	mov	r3, r0
 8000968:	6039      	str	r1, [r7, #0]
 800096a:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  assert_param(IS_FLASH_BANK(Banks));

  /* If the previous operation is completed, proceed to erase all sectors */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 800096c:	4b0d      	ldr	r3, [pc, #52]	; (80009a4 <FLASH_MassErase+0x44>)
 800096e:	691b      	ldr	r3, [r3, #16]
 8000970:	4a0c      	ldr	r2, [pc, #48]	; (80009a4 <FLASH_MassErase+0x44>)
 8000972:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000976:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_MER;
 8000978:	4b0a      	ldr	r3, [pc, #40]	; (80009a4 <FLASH_MassErase+0x44>)
 800097a:	691b      	ldr	r3, [r3, #16]
 800097c:	4a09      	ldr	r2, [pc, #36]	; (80009a4 <FLASH_MassErase+0x44>)
 800097e:	f043 0304 	orr.w	r3, r3, #4
 8000982:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange << 8U);
 8000984:	4b07      	ldr	r3, [pc, #28]	; (80009a4 <FLASH_MassErase+0x44>)
 8000986:	691a      	ldr	r2, [r3, #16]
 8000988:	79fb      	ldrb	r3, [r7, #7]
 800098a:	021b      	lsls	r3, r3, #8
 800098c:	4313      	orrs	r3, r2
 800098e:	4a05      	ldr	r2, [pc, #20]	; (80009a4 <FLASH_MassErase+0x44>)
 8000990:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000994:	6113      	str	r3, [r2, #16]
}
 8000996:	bf00      	nop
 8000998:	370c      	adds	r7, #12
 800099a:	46bd      	mov	sp, r7
 800099c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80009a0:	4770      	bx	lr
 80009a2:	bf00      	nop
 80009a4:	40023c00 	.word	0x40023c00

080009a8 <FLASH_Erase_Sector>:
  *                                  the operation will be done by double word (64-bit)
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
{
 80009a8:	b480      	push	{r7}
 80009aa:	b085      	sub	sp, #20
 80009ac:	af00      	add	r7, sp, #0
 80009ae:	6078      	str	r0, [r7, #4]
 80009b0:	460b      	mov	r3, r1
 80009b2:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp_psize = 0U;
 80009b4:	2300      	movs	r3, #0
 80009b6:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));

  if (VoltageRange == FLASH_VOLTAGE_RANGE_1)
 80009b8:	78fb      	ldrb	r3, [r7, #3]
 80009ba:	2b00      	cmp	r3, #0
 80009bc:	d102      	bne.n	80009c4 <FLASH_Erase_Sector+0x1c>
  {
    tmp_psize = FLASH_PSIZE_BYTE;
 80009be:	2300      	movs	r3, #0
 80009c0:	60fb      	str	r3, [r7, #12]
 80009c2:	e010      	b.n	80009e6 <FLASH_Erase_Sector+0x3e>
  }
  else if (VoltageRange == FLASH_VOLTAGE_RANGE_2)
 80009c4:	78fb      	ldrb	r3, [r7, #3]
 80009c6:	2b01      	cmp	r3, #1
 80009c8:	d103      	bne.n	80009d2 <FLASH_Erase_Sector+0x2a>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 80009ca:	f44f 7380 	mov.w	r3, #256	; 0x100
 80009ce:	60fb      	str	r3, [r7, #12]
 80009d0:	e009      	b.n	80009e6 <FLASH_Erase_Sector+0x3e>
  }
  else if (VoltageRange == FLASH_VOLTAGE_RANGE_3)
 80009d2:	78fb      	ldrb	r3, [r7, #3]
 80009d4:	2b02      	cmp	r3, #2
 80009d6:	d103      	bne.n	80009e0 <FLASH_Erase_Sector+0x38>
  {
    tmp_psize = FLASH_PSIZE_WORD;
 80009d8:	f44f 7300 	mov.w	r3, #512	; 0x200
 80009dc:	60fb      	str	r3, [r7, #12]
 80009de:	e002      	b.n	80009e6 <FLASH_Erase_Sector+0x3e>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 80009e0:	f44f 7340 	mov.w	r3, #768	; 0x300
 80009e4:	60fb      	str	r3, [r7, #12]
  }

  /* If the previous operation is completed, proceed to erase the sector */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 80009e6:	4b13      	ldr	r3, [pc, #76]	; (8000a34 <FLASH_Erase_Sector+0x8c>)
 80009e8:	691b      	ldr	r3, [r3, #16]
 80009ea:	4a12      	ldr	r2, [pc, #72]	; (8000a34 <FLASH_Erase_Sector+0x8c>)
 80009ec:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80009f0:	6113      	str	r3, [r2, #16]
  FLASH->CR |= tmp_psize;
 80009f2:	4b10      	ldr	r3, [pc, #64]	; (8000a34 <FLASH_Erase_Sector+0x8c>)
 80009f4:	691a      	ldr	r2, [r3, #16]
 80009f6:	490f      	ldr	r1, [pc, #60]	; (8000a34 <FLASH_Erase_Sector+0x8c>)
 80009f8:	68fb      	ldr	r3, [r7, #12]
 80009fa:	4313      	orrs	r3, r2
 80009fc:	610b      	str	r3, [r1, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
 80009fe:	4b0d      	ldr	r3, [pc, #52]	; (8000a34 <FLASH_Erase_Sector+0x8c>)
 8000a00:	691b      	ldr	r3, [r3, #16]
 8000a02:	4a0c      	ldr	r2, [pc, #48]	; (8000a34 <FLASH_Erase_Sector+0x8c>)
 8000a04:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8000a08:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
 8000a0a:	4b0a      	ldr	r3, [pc, #40]	; (8000a34 <FLASH_Erase_Sector+0x8c>)
 8000a0c:	691a      	ldr	r2, [r3, #16]
 8000a0e:	687b      	ldr	r3, [r7, #4]
 8000a10:	00db      	lsls	r3, r3, #3
 8000a12:	4313      	orrs	r3, r2
 8000a14:	4a07      	ldr	r2, [pc, #28]	; (8000a34 <FLASH_Erase_Sector+0x8c>)
 8000a16:	f043 0302 	orr.w	r3, r3, #2
 8000a1a:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_STRT;
 8000a1c:	4b05      	ldr	r3, [pc, #20]	; (8000a34 <FLASH_Erase_Sector+0x8c>)
 8000a1e:	691b      	ldr	r3, [r3, #16]
 8000a20:	4a04      	ldr	r2, [pc, #16]	; (8000a34 <FLASH_Erase_Sector+0x8c>)
 8000a22:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000a26:	6113      	str	r3, [r2, #16]
}
 8000a28:	bf00      	nop
 8000a2a:	3714      	adds	r7, #20
 8000a2c:	46bd      	mov	sp, r7
 8000a2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a32:	4770      	bx	lr
 8000a34:	40023c00 	.word	0x40023c00

08000a38 <FLASH_FlushCaches>:
/**
  * @brief  Flush the instruction and data caches
  * @retval None
  */
void FLASH_FlushCaches(void)
{
 8000a38:	b480      	push	{r7}
 8000a3a:	af00      	add	r7, sp, #0
  /* Flush instruction cache  */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != RESET)
 8000a3c:	4b20      	ldr	r3, [pc, #128]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a3e:	681b      	ldr	r3, [r3, #0]
 8000a40:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8000a44:	2b00      	cmp	r3, #0
 8000a46:	d017      	beq.n	8000a78 <FLASH_FlushCaches+0x40>
  {
    /* Disable instruction cache  */
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8000a48:	4b1d      	ldr	r3, [pc, #116]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a4a:	681b      	ldr	r3, [r3, #0]
 8000a4c:	4a1c      	ldr	r2, [pc, #112]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a4e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000a52:	6013      	str	r3, [r2, #0]
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 8000a54:	4b1a      	ldr	r3, [pc, #104]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a56:	681b      	ldr	r3, [r3, #0]
 8000a58:	4a19      	ldr	r2, [pc, #100]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a5a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000a5e:	6013      	str	r3, [r2, #0]
 8000a60:	4b17      	ldr	r3, [pc, #92]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a62:	681b      	ldr	r3, [r3, #0]
 8000a64:	4a16      	ldr	r2, [pc, #88]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a66:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000a6a:	6013      	str	r3, [r2, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8000a6c:	4b14      	ldr	r3, [pc, #80]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a6e:	681b      	ldr	r3, [r3, #0]
 8000a70:	4a13      	ldr	r2, [pc, #76]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a72:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000a76:	6013      	str	r3, [r2, #0]
  }

  /* Flush data cache */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 8000a78:	4b11      	ldr	r3, [pc, #68]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a7a:	681b      	ldr	r3, [r3, #0]
 8000a7c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8000a80:	2b00      	cmp	r3, #0
 8000a82:	d017      	beq.n	8000ab4 <FLASH_FlushCaches+0x7c>
  {
    /* Disable data cache  */
    __HAL_FLASH_DATA_CACHE_DISABLE();
 8000a84:	4b0e      	ldr	r3, [pc, #56]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a86:	681b      	ldr	r3, [r3, #0]
 8000a88:	4a0d      	ldr	r2, [pc, #52]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a8a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000a8e:	6013      	str	r3, [r2, #0]
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
 8000a90:	4b0b      	ldr	r3, [pc, #44]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a92:	681b      	ldr	r3, [r3, #0]
 8000a94:	4a0a      	ldr	r2, [pc, #40]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a96:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000a9a:	6013      	str	r3, [r2, #0]
 8000a9c:	4b08      	ldr	r3, [pc, #32]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000a9e:	681b      	ldr	r3, [r3, #0]
 8000aa0:	4a07      	ldr	r2, [pc, #28]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000aa2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000aa6:	6013      	str	r3, [r2, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
 8000aa8:	4b05      	ldr	r3, [pc, #20]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000aaa:	681b      	ldr	r3, [r3, #0]
 8000aac:	4a04      	ldr	r2, [pc, #16]	; (8000ac0 <FLASH_FlushCaches+0x88>)
 8000aae:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000ab2:	6013      	str	r3, [r2, #0]
  }
}
 8000ab4:	bf00      	nop
 8000ab6:	46bd      	mov	sp, r7
 8000ab8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000abc:	4770      	bx	lr
 8000abe:	bf00      	nop
 8000ac0:	40023c00 	.word	0x40023c00

08000ac4 <__libc_init_array>:
 8000ac4:	b570      	push	{r4, r5, r6, lr}
 8000ac6:	4d0d      	ldr	r5, [pc, #52]	; (8000afc <__libc_init_array+0x38>)
 8000ac8:	4c0d      	ldr	r4, [pc, #52]	; (8000b00 <__libc_init_array+0x3c>)
 8000aca:	1b64      	subs	r4, r4, r5
 8000acc:	10a4      	asrs	r4, r4, #2
 8000ace:	2600      	movs	r6, #0
 8000ad0:	42a6      	cmp	r6, r4
 8000ad2:	d109      	bne.n	8000ae8 <__libc_init_array+0x24>
 8000ad4:	4d0b      	ldr	r5, [pc, #44]	; (8000b04 <__libc_init_array+0x40>)
 8000ad6:	4c0c      	ldr	r4, [pc, #48]	; (8000b08 <__libc_init_array+0x44>)
 8000ad8:	f000 f818 	bl	8000b0c <_init>
 8000adc:	1b64      	subs	r4, r4, r5
 8000ade:	10a4      	asrs	r4, r4, #2
 8000ae0:	2600      	movs	r6, #0
 8000ae2:	42a6      	cmp	r6, r4
 8000ae4:	d105      	bne.n	8000af2 <__libc_init_array+0x2e>
 8000ae6:	bd70      	pop	{r4, r5, r6, pc}
 8000ae8:	f855 3b04 	ldr.w	r3, [r5], #4
 8000aec:	4798      	blx	r3
 8000aee:	3601      	adds	r6, #1
 8000af0:	e7ee      	b.n	8000ad0 <__libc_init_array+0xc>
 8000af2:	f855 3b04 	ldr.w	r3, [r5], #4
 8000af6:	4798      	blx	r3
 8000af8:	3601      	adds	r6, #1
 8000afa:	e7f2      	b.n	8000ae2 <__libc_init_array+0x1e>
 8000afc:	08000b24 	.word	0x08000b24
 8000b00:	08000b24 	.word	0x08000b24
 8000b04:	08000b24 	.word	0x08000b24
 8000b08:	08000b28 	.word	0x08000b28

08000b0c <_init>:
 8000b0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000b0e:	bf00      	nop
 8000b10:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000b12:	bc08      	pop	{r3}
 8000b14:	469e      	mov	lr, r3
 8000b16:	4770      	bx	lr

08000b18 <_fini>:
 8000b18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000b1a:	bf00      	nop
 8000b1c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000b1e:	bc08      	pop	{r3}
 8000b20:	469e      	mov	lr, r3
 8000b22:	4770      	bx	lr
